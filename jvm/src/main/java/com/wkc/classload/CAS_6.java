package com.wkc.classload;

/**
 * Created on 2022/3/2.
 *
 * @author Weikaichen
 */
public class CAS_6 {
    /*
     * CAS
     * CAS即Compare and Swap,它体现的是一种乐观锁的思想
     * 获取共享变量时，为了保证该变量的可见性，需要使用volatile修饰，结合CAS和volatile可以
     * 实现无锁并发，适用于竞争不激烈，多核CPU的场景下
     * 由于没有使用synchronized，所以线程不会陷入阻塞，这是效率提升的因素之一
     * 但如果竞争激烈，可以想到重试必然频繁发生，反而效率会受影响
     * CAS底层以来与一个Unsafe类直接调用操作系统的底层CAS指令，下面是直接使用Unsafe对象
     * 进行线程安全保护的一个例子
     * */


    /*
     * 乐观锁
     * CAS是基于乐观锁的思想：最乐观的估计，不怕别的线程来修改共享变量，就算改了也没关系，
     * 重试
     *
     * 悲观锁
     * synchronized是基于悲观锁的思想，最悲观的估计，得防着其他线程来修改共享变量。
     *
     *
     * */

    /*
     * JUC
     * juc（java.util.concurrent）中提供了原子操作类，可以提供线程安全的操作，例如：AtomicInteger，AtommicBoolean
     * 底层就是采用CAS+Volatile实现的
     *
     * */

    /*
     *
     * synchronized优化
     * Java HotSpot虚拟机中，每个对象都有对象头（包括class指针和mark Word）。mark word平时存储这个对象的哈希码，分代年龄
     * 当加锁时，这些信息就根据情况被替换成为标记位,线程记录指针，重量级锁指针，线程Id等内容
     * */

    /*
     * 轻量级锁
     * 如果一个对象虽然有多线程访问，但是多线程访问的时间是错开的（也就是没有竞争），
     * 那么就可以使用轻量级锁来优化
     *
     * 线程A用课本占座，上了半节课，出门了（CPU时间到），回来看，发现课本没变，说明没有竞争，继续上课
     * 如果这期间有线程B来了，会告知线程A有并发访问，线程A随机升级为重量级锁，进入重量级锁流程
     * 而重量级锁就不是课本占座那么简单了，可以想象线程A走之前，把座位用一个铁栅栏围起来
     *
     *
     * 锁膨胀
     * 如果在尝试轻量级锁过程中，CAS操作无法成功，这时一种情况就是有其他线程为此对象加上了轻量级锁（有竞争）
     * 这时需要进行锁膨胀，将轻量级锁百年城重量级锁
     *
     * */

    /*
     * 重量锁
     * 重量级锁竞争的时候，还可以使用自旋来进行优化，如果当前线程自旋成功，（即这个时候锁线程已经退出了同步块，释放了锁），
     * 这时当前线程就可以避免阻塞
     *
     * 在JAVA6之后自旋锁是自适应的，比如对象刚刚的一次自旋操作成功过，那么认为这次自旋成功的可能性会高，就多自旋几次，反之
     * 就少自旋甚至不自旋
     * 自旋会占用cpu时间，单核CPU自旋就是浪费，多核Cpu自旋才能发挥优势
     * */

    /*
     * 偏向锁
     * 轻量级锁在没有竞争时（就自己这个线程），每次重入依然需要CAS操作，JAVA6中引入了偏向锁
     * 来做进一步优化，只有第一次CAS将线程ID设置到对象的MARK Word头，之后发现这个线程id就是自己的
     * 就表示没有竞争，不用重新CAS
     *
     * 撤销偏向需要将锁线程升级为轻量级锁，这个过程中所有的线程需要暂停（STW）
     * 访问对象的HashCode也会撤销偏向锁（hashCode存在mark word中）
     * 如果对象虽然被多个线程访问，但是没有竞争，这时偏向了线程T1的对象有机会偏向T2，重偏向重置对象的ThreadID
     * 撤销偏向和重偏向都是批量进行的，以类为单位
     * 如果撤销偏向到达某个阈值，整个类的所有对象都会变为不可偏向的
     * 可以主动使用-XX:-UseBasedLocking
     * */

    /*
     * 其他优化
     * 1.减少上锁时间
     * 同步代码中尽量短
     * 2.减少锁的粒度
     * 将一个锁拆分为多个锁提高并发度 例如：ConcurrentHashMap
     * 3.锁粗化
     * 多次循环进入同步块不如同步块多次循环
     * 另外JVM可能会做，把多次append的加锁操作粗化为一次，都是对同一个对象加锁，没必要
     * 重入多次
     * new StringBuffer().append("a").append("b")
     * 4.锁消除
     * JVM会进行代码的逃逸分析，例如某个加锁对象是方法内局部变量，不会被其他线程访问到，
     * 这时候就会被即时编译器忽略到同步操作
     * 5.读写分离
     * CopyOnWriteArrayList
     * CopyonWriteSet
     *
     * */
}
