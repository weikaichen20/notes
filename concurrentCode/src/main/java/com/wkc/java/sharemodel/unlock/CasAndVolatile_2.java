package com.wkc.java.sharemodel.unlock;

/**
 * Created on 2022/3/24.
 *
 * @author Weikaichen
 */
public class CasAndVolatile_2 {
    /*
     * AtomInteger解决方法，内部并没有用锁来保护共享变量的线程安全
     * 关键是compareAndSet，简称CAS，她是原子操作的
     *
     *       注意
     * 其实CAS的底层是lock cmpxhg指令（X86架构），在单核CPU和多核Cpu下都能保证【比较-交换】的原子性
     * 在多核状态下，某个核执行到带lock的指令时，cpu会让总线锁住，当这个核把此指令执行完毕，再开启总线
     * 这个过程不会被线程的调度机制打断，保证多个线程对内存操作的准确性，是原子的
     *
     *
     *  volatile
     * 获取共享变量时，为了保证变量的可见性，需要使用volatile修饰
     *
     * 它可以用来修饰成员变量和静态成员变量，它可以避免线程在自己的工作缓存中查找变量的值，必须到
     * 主存中获取它的值，线程操作volatile变量都是直接操作主存，即一个线程对volatile变量的修改
     * 对另一个线程可见
     *   注意
     * volatile仅仅保证了共享变量的可见性，让其他线程能看到最新值，但不能解决指令交错问题（不能保证原子性）（指令交错和指令重排是不一样的）
     *
     * CAS必须借助volatile才能读取到共享变量的最新值来实现【比较并交换】的效果
     *
     * */

    /*
     *          为什么无锁的效率高
     * 无锁情况下，即时重试失败，线程始终在高速运行，没有停歇，而synchronized会让线程没有获得锁的，发生线程上下文切换。进入阻塞状态
     *
     *      比喻
     * 线程好像高速跑道上的赛车，高速运行时，速度超快，一旦发生上下文切换，就好比赛车要减速，熄火，等被唤醒又得重新打火
     * 启动加速，恢复到高速运行，代价比较大
     *
     * 但是无锁情况下，因为线程要保持运行，需要额外支持的CPU的支持，CPU在这里好比高速跑道，没有额外的跑道
     * 线程想高速运行也无从谈起，虽然不会进入阻塞，但是由于没有分到时间片，会进入可运行状态，还是会导致上下文切换
     * */


    /*      CAS的特点
     * 结合CAS和volatile可以实现无锁并发，适用于【线程数少，多核Cpu】的场景下
     * 1.CAS是基于乐观锁的实现，最乐观的估计，部派别的线程来修改共享变量，改了就重试
     * 2.synchronized是基于悲观锁的思想：最悲观的估计，得防着其他线程来修改共享变量，改完解开锁，别的线程才有机会
     *
     *  CAS体现的时无锁并发，无阻塞并发，
     *      因为没有使用synchronized，所以线程不会陷入阻塞，这是效率提升的因素之一
     *      如果竞争激烈，重试发生必然频繁，反而效率会受影响
     *
     *
     *
     * */
}
