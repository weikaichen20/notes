package nio.block;

/**
 * Created on 2022/3/14.
 *
 * @author Weikaichen
 */
public class NIO_vs_BIO_10 {
    /*
     * stream vs channel
     * stream不会自动缓冲数据，channel会利用系统提供的发送缓冲区，接收缓冲区（更为底层）
     * stream仅支持阻塞API，channe同时支持阻塞，非阻塞API，网络Channel配合Selector实现多路复用
     * 二者均为全双工，读写可以同时进行
     * */

    /*
     * IO模型
     * 同步阻塞，同步非阻塞，多路复用，异步阻塞（没有此情况），异步非阻塞
     *
     * 当调用一次channel.read()或stream.read()后，会切换至操作系统内核态来完成真正的数据读取，而读取又分为两个阶段，
     * 等待数据阶段
     * 复制数据阶段
     *
     * 阻塞IO
     * 非阻塞IO
     * 多路复用
     * 信号驱动
     *
     * 同步：线程自己去获取结果（一个线程）
     * 异步：线程自己不去获取结果，而是由其他线程送结果（至少两个线程）
     *
     * */


    /*
     * 零拷贝
     * 1.java本身并不具备IO读写能力，因此read方法调用后，要从java程序的用户态切换至内核态，
     * 去调用操作系统(Kernel)的读能力，将数据读入内核缓冲区，期间用户线程阻塞，操作系统使用DMA（Direct Memory Access）
     * 来实现文件读，期间也不会使用cpu。
     *   DMA可以理解为硬件单元，用来解放cpu完成文件io
     *
     * 2.从内核态切换回用户态，将数据从内存缓冲区读入用户缓冲区，这期间cpu会参与拷贝，无法利用DMA
     * 3.调用write方法将数据从用户缓冲区写入socket缓冲区，cpu参与拷贝
     * 4.要向网卡写数据，java不具备，因此又得从用户态切换至内核态，调用操作系统的写能力，使用DMA将socket
     * 缓冲区的数据写入网卡，不会使用cpu
     *
     * java的io实际不是物理设备的级别的读写，而是缓存的复制，底层的真正读写是操作系统来完成的
     * 用户态与内核态的切换发生了3次，这个操作比较重量级
     * 数据拷贝了4次
     *
     * NIO优化
     * 通过DirectByteBuffer
     * java 可以使用 DirectByteBuf 将堆外内存映射到 jvm 内存中来直接访问使用

     * 这块内存不受 jvm 垃圾回收的影响，因此内存地址固定，有助于 IO 读写
     * java 中的 DirectByteBuf 对象仅维护了此内存的虚引用，内存回收分成两步
     * DirectByteBuf 对象被垃圾回收，将虚引用加入引用队列
     * 通过专门线程访问引用队列，根据虚引用释放堆外内存
     * 减少了一次数据拷贝，用户态与内核态的切换次数没有减少
     *
     *
     * 进一步优化使用tansferTo =》查看md
     *
     *
     * 【零拷贝】，并不是真正无拷贝，而是在不会拷贝重复数据到 jvm 内存中，零拷贝的优点有
     * 更少的用户态与内核态的切换
     * 不利用 cpu 计算，减少 cpu 缓存伪共享
     * 零拷贝适合小文件传输
     * */
}
